<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Theoçš„ç¢ç¢å¿µæ”¶çº³å¤„</title>
  <style>
    :root { color-scheme: light; }
    *, *::before, *::after{ box-sizing: border-box; }
    body{
      margin:0;
      min-height:100svh;
      font-family:-apple-system,BlinkMacSystemFont,"PingFang SC","Segoe UI",Roboto,Helvetica,Arial,sans-serif;
      background:
        radial-gradient(1200px 700px at 10% 10%, rgba(30,90,191,0.20), transparent 60%),
        radial-gradient(1000px 650px at 85% 20%, rgba(90,167,255,0.18), transparent 55%),
        radial-gradient(900px 700px at 50% 92%, rgba(231,240,255,0.80), transparent 62%),
        linear-gradient(180deg, #f7faff, #ffffff);
      overflow-x:hidden;
    }
    .wrap{max-width: 860px; margin:0 auto; padding: 18px;}
    .top{display:flex; align-items:center; justify-content:space-between; gap:12px; flex-wrap:wrap;}
    h1{margin: 6px 0; font-size:22px; color: rgba(0,0,0,0.84);}
    .sub{margin:0; font-size:13px; color: rgba(0,0,0,0.52); line-height:1.6}

    .card{
      margin-top:14px;
      border-radius: 24px;
      background: linear-gradient(180deg, rgba(255,255,255,0.80), rgba(255,255,255,0.62));
      border: 1px solid rgba(31,102,227,0.12);
      box-shadow:
        0 28px 80px rgba(11,42,120,0.12),
        inset 0 1px 0 rgba(255,255,255,0.55);
      backdrop-filter: blur(16px);
      padding: 16px;
      position: relative;
      overflow: hidden;
    }
    .card::before{
      content:"";
      position:absolute;
      inset:-2px;
      background:
        radial-gradient(500px 220px at 10% 5%, rgba(90,167,255,0.26), transparent 55%),
        radial-gradient(420px 240px at 90% 0%, rgba(11,42,120,0.14), transparent 60%);
      opacity: 0.55;
      pointer-events:none;
    }
    .card > *{ position: relative; }
    label{display:block; margin-top:12px; font-size:12px; color: rgba(0,0,0,0.55)}
    textarea{
      width:100%;
      box-sizing: border-box;
      min-height: 120px;
      resize: vertical;
      margin-top: 8px;
      border-radius: 18px;
      border: 1px solid rgba(31,102,227,0.16);
      padding: 12px;
      font-size: 14px;
      outline: none;
      background: rgba(255,255,255,0.92);
      line-height: 1.75;
      box-shadow: inset 0 1px 0 rgba(255,255,255,0.6);
    }
    textarea:focus{
      border-color: rgba(31,102,227,0.35);
      box-shadow: 0 0 0 4px rgba(90,167,255,0.18);
    }
    input[type=file]{margin-top:8px; max-width: 100%;}

    .thumbs{margin-top:10px; display:flex; gap:10px; flex-wrap:wrap;}
    .thumb{
      width:84px; height:84px; border-radius:18px; border:1px solid rgba(0,0,0,0.06);
      background: rgba(255,255,255,0.74);
      box-shadow: 0 12px 28px rgba(11,42,120,0.10);
      position:relative; overflow:hidden;
    }
    .thumb img{width:100%; height:100%; object-fit:cover; display:block;}
    .thumb button{
      position:absolute; top:6px; right:6px;
      width:26px; height:26px; border-radius:999px;
      padding:0; border:0; cursor:pointer;
      background: rgba(0,0,0,0.55); color:#fff;
      box-shadow:none;
    }
    .thumb button:active{ transform: scale(0.96); }

    .btns{margin-top:12px; display:flex; gap:10px; flex-wrap:wrap;}
    button, a.btn{
      border:0;
      border-radius: 999px;
      padding: 10px 14px;
      font-size: 14px;
      cursor:pointer;
      background: rgba(255,255,255,0.82);
      box-shadow: 0 10px 24px rgba(0,0,0,0.08);
      color: rgba(0,0,0,0.78);
      user-select:none;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
      text-decoration:none;
      display:inline-block;
    }
    button.primary{
      background: linear-gradient(135deg, #0b2a78, #5aa7ff);
      color:#fff;
      font-weight:900;
      letter-spacing: 0.2px;
      box-shadow: 0 14px 34px rgba(31,102,227,0.22);
    }
    button.primary:disabled{opacity:0.6; cursor:not-allowed;}

    .pill{
      border: 1px solid rgba(31,102,227,0.14);
      background: rgba(255,255,255,0.72);
    }

    .list{margin-top: 14px; display:grid; gap:10px;}
    .item{
      border-radius: 18px;
      border: 1px solid rgba(0,0,0,0.06);
      background: rgba(255,255,255,0.68);
      padding: 12px;
    }
    .meta{font-size:12px; color: rgba(0,0,0,0.48); word-break: break-all;}
    .text{margin-top:6px; white-space: pre-wrap; font-size:14px; color: rgba(0,0,0,0.72); line-height:1.7;}
    .imgs{margin-top:10px; display:flex; gap:8px; flex-wrap:wrap;}
    .imgs img{width:110px; height:110px; object-fit:cover; border-radius:14px; border:1px solid rgba(0,0,0,0.06)}

    .note{margin-top:12px; font-size:12px; color: rgba(0,0,0,0.46); line-height:1.6}

    /* reactions + reply */
    .replyRow{margin-top:10px; display:flex; align-items:center; justify-content:space-between; gap:10px; flex-wrap:wrap;}
    .replyBtn{
      border: 1px solid rgba(31,102,227,0.14);
      background: rgba(255,255,255,0.74);
      border-radius: 999px;
      padding: 8px 12px;
      font-size: 13px;
      cursor: pointer;
      box-shadow: 0 10px 22px rgba(0,0,0,0.06);
      color: rgba(0,0,0,0.78);
      user-select:none;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
    }
    .replySummary{font-size:12px; color: rgba(0,0,0,0.46); line-height:1.5; flex:1; min-width: 200px;}

    .replyPanel{
      width:100%;
      margin-top:10px;
      border-radius: 18px;
      border: 1px solid rgba(31,102,227,0.12);
      background: rgba(255,255,255,0.64);
      padding: 12px;
      display:none;
    }

    .reactions{display:flex; gap:8px; flex-wrap:wrap; align-items:flex-start;}
    .reactBtn{
      border: 1px solid rgba(31,102,227,0.14);
      background: rgba(255,255,255,0.74);
      border-radius: 999px;
      padding: 8px 10px;
      font-size: 13px;
      line-height: 1;
      cursor: pointer;
      box-shadow: 0 10px 22px rgba(0,0,0,0.06);
      color: rgba(0,0,0,0.78);
      display:flex;
      align-items:center;
      gap:6px;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
    }
    .reactBtn.on{
      background: linear-gradient(135deg, rgba(11,42,120,0.10), rgba(90,167,255,0.22));
      border-color: rgba(31,102,227,0.26);
      box-shadow: 0 14px 30px rgba(31,102,227,0.12);
    }
    .reactIcon{font-size: 15px;}
    .reactCount{font-weight: 900; font-size: 12px; color: rgba(0,0,0,0.58)}
    .reactWho{font-size: 11px; color: rgba(0,0,0,0.45); margin-top: 2px; padding-left: 8px;}
    .reactWrap{display:flex; flex-direction:column; align-items:flex-start;}

    .commentBox{margin-top:10px; display:flex; gap:10px; align-items:center;}
    .draftReacts{font-size:12px; color: rgba(0,0,0,0.48); margin-left:auto;}
    .commentInput{
      flex: 1;
      min-width: 200px;
      border-radius: 16px;
      border: 1px solid rgba(31,102,227,0.16);
      padding: 10px 12px;
      font-size: 13px;
      outline:none;
      background: rgba(255,255,255,0.92);
      line-height: 1.2;
      height: 38px;
    }
    .commentList{margin-top:10px; display:grid; gap:8px;}
    .commentItem{border-radius: 14px; border: 1px solid rgba(0,0,0,0.06); background: rgba(255,255,255,0.70); padding: 10px;}
    .commentMeta{font-size:11px; color: rgba(0,0,0,0.45)}
    .commentText{margin-top:4px; font-size:13px; color: rgba(0,0,0,0.72); white-space: pre-wrap; line-height:1.65}

    /* calendar */
    .calHead{margin-top:10px; display:flex; align-items:center; justify-content:space-between; gap:10px;}
    .calTitle{font-weight:950; color: rgba(0,0,0,0.78);}
    .calWeek{margin-top:10px; display:grid; grid-template-columns: repeat(7, minmax(0, 1fr)); gap:8px;}
    .calWeek div{font-size:12px; color: rgba(0,0,0,0.42); text-align:center; padding: 2px 0;}
    .calGrid{margin-top:8px; display:grid; grid-template-columns: repeat(7, minmax(0, 1fr)); gap:8px;}
    .calCell{
      border-radius: 16px;
      border: 1px solid rgba(31,102,227,0.10);
      background: rgba(255,255,255,0.62);
      padding: 10px 8px;
      min-height: 48px;
      cursor:pointer;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
      position: relative;
      transition: transform 120ms ease, box-shadow 120ms ease;
    }
    .calCell:active{ transform: scale(0.98); }
    .calCell.dim{opacity:0.42; cursor:default;}
    .calCell.has{
      background: linear-gradient(135deg, rgba(90,167,255,0.22), rgba(11,42,120,0.10));
      border-color: rgba(31,102,227,0.22);
      box-shadow: 0 14px 34px rgba(11,42,120,0.10);
    }
    .calCell.today{outline: 2px solid rgba(90,167,255,0.32);}
    .calCell.sel{outline: 3px solid rgba(11,42,120,0.20);}
    .calNum{font-weight:950; color: rgba(0,0,0,0.72); font-size:14px;}
    .calDot{position:absolute; right:10px; bottom:10px; width:8px; height:8px; border-radius:999px;
      background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.9), rgba(90,167,255,0.9));
      box-shadow: 0 8px 18px rgba(31,102,227,0.22);
    }

    .toast{position:fixed; left:50%; bottom: 16px; transform: translateX(-50%);
      background: rgba(0,0,0,0.80); color:#fff; padding: 10px 14px; border-radius: 999px; font-size: 13px;
      box-shadow: 0 18px 50px rgba(0,0,0,0.20); display:none; max-width: calc(100% - 24px); text-align:center;}

    @media (max-width: 560px){
      .wrap{padding: 14px;}
      .imgs img{width: 96px; height: 96px;}
    }
  </style>
</head>
<body>
  <script>
    (function(){
      const USERS = new Set(['Theo','Evie']);
      const base = '/' + (location.pathname.split('/').filter(Boolean)[0] || '');
      try {
        const ok = localStorage.getItem('theo_auth_ok') === '1';
        const user = localStorage.getItem('theo_auth_user') || '';
        if (!ok || !USERS.has(user)) {
          location.replace(base + '/?next=' + encodeURIComponent(location.pathname.slice(base.length) + location.search + location.hash));
          return;
        }
        window.__AUTH__ = { user };
      } catch {
        location.replace(base + '/');
      }
    })();
  </script>

  <div class="wrap">
    <div class="top">
      <div>
        <h1>Theoçš„ç¢ç¢å¿µæ”¶çº³å¤„</h1>
        <p class="sub">æŠŠä»Šå¤©çš„å°æƒ…ç»ªã€å°å¿«ä¹ã€å°ç¢ç¢å¿µâ€¦éƒ½æ‚„æ‚„æ”¶è¿›æ¥ã€‚</p>
      </div>
      <a class="btn" href="../greeting/">è¿”å›é—®å€™é¡µ</a>
    </div>

    <div class="card">
      <label>æƒ³å†™ç‚¹ä»€ä¹ˆï¼Ÿ</label>
      <textarea id="text" placeholder="æ¯”å¦‚ï¼šä»Šå¤©çš„å¿ƒæƒ…ã€æƒ³åƒçš„ä¸œè¥¿ã€å‘ç”Ÿçš„å°äº‹â€¦"></textarea>

      <label>ä¸Šä¼ ç…§ç‰‡ï¼ˆå¯å¤šå¼ ï¼‰</label>
      <input id="photos" type="file" accept="image/*" multiple />
      <div class="thumbs" id="thumbs"></div>

      <div class="btns">
        <button class="primary" id="saveGitHub">è®°å½•</button>
      </div>

      <div class="note">
        å°æç¤ºï¼šç…§ç‰‡å¯ä»¥å¤šå¼ ï¼Œç‚¹ç¼©ç•¥å›¾èƒ½æ”¾å¤§çœ‹ã€‚
      </div>
    </div>

    <div class="card">
      <div class="meta">æ—¥å†</div>
      <div class="calHead">
        <button class="pill" id="prevM">â†</button>
        <div class="calTitle" id="calTitle"></div>
        <div style="display:flex; gap:8px;">
          <button class="pill" id="todayBtn">ä»Šå¤©</button>
          <button class="pill" id="nextM">â†’</button>
        </div>
      </div>
      <div class="calWeek" id="calWeek"></div>
      <div class="calGrid" id="calGrid"></div>
      <div class="note">ç‚¹æ—¥æœŸæŸ¥çœ‹å½“å¤©ç¢ç¢å¿µï¼›æœ‰è®°å½•çš„æ—¥æœŸä¼šå‘å…‰ã€‚</div>
    </div>

    <div class="card">
      <div class="meta" id="dayTitle">å·²ä¿å­˜çš„è®°å½•ï¼ˆä»ä»“åº“è¯»å–ï¼‰</div>
      <div class="list" id="list"></div>
    </div>
  </div>

  <div class="toast" id="toast"></div>

  <div id="imgModal" style="position:fixed; inset:0; display:none; place-items:center; padding:18px; background:rgba(10,16,30,0.72); backdrop-filter: blur(10px); z-index:200;">
    <div style="position:relative; width:min(920px, 100%); max-height: 90svh;">
      <button id="imgClose" style="position:absolute; top:-10px; right:-10px; width:42px; height:42px; border-radius:999px; border:1px solid rgba(255,255,255,0.20); background:rgba(255,255,255,0.14); color:#fff; cursor:pointer;">Ã—</button>
      <img id="imgBig" alt="photo" style="width:100%; max-height: 90svh; object-fit:contain; border-radius: 22px; border:1px solid rgba(255,255,255,0.16); box-shadow: 0 28px 90px rgba(0,0,0,0.35); background: rgba(255,255,255,0.06);" />
    </div>
  </div>

  <script>
    const $ = (id) => document.getElementById(id);
    const toast = (msg) => {
      const t = $('toast');
      t.textContent = msg;
      t.style.display = 'block';
      clearTimeout(toast._t);
      toast._t = setTimeout(() => t.style.display = 'none', 1600);
    };

    // image modal
    const imgModal = $('imgModal');
    const imgBig = $('imgBig');
    const imgClose = $('imgClose');
    function openImg(src){
      if (!imgModal || !imgBig) return;
      imgBig.src = src;
      imgModal.style.display = 'grid';
    }
    function closeImg(){
      if (!imgModal) return;
      imgModal.style.display = 'none';
      if (imgBig) imgBig.src = '';
    }
    imgClose && (imgClose.onclick = closeImg);
    imgModal && imgModal.addEventListener('click', (e) => { if (e.target === imgModal) closeImg(); });
    window.addEventListener('keydown', (e) => { if (e.key === 'Escape') closeImg(); });

    // photo preview
    let selectedFiles = [];
    const thumbsEl = $('thumbs');
    function renderThumbs(){
      if (!thumbsEl) return;
      thumbsEl.innerHTML = '';
      selectedFiles.forEach((f, idx) => {
        const div = document.createElement('div');
        div.className = 'thumb';
        const img = document.createElement('img');
        img.alt = 'preview';
        img.src = URL.createObjectURL(f);
        img.onclick = () => openImg(img.src);
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.textContent = 'Ã—';
        btn.onclick = () => {
          selectedFiles.splice(idx, 1);
          renderThumbs();
        };
        div.appendChild(img);
        div.appendChild(btn);
        thumbsEl.appendChild(div);
      });
    }
    const photosInput = $('photos');
    photosInput && photosInput.addEventListener('change', () => {
      selectedFiles = Array.from(photosInput.files || []);
      renderThumbs();
    });

    // --- Passcode gate + encrypted token ---
    const KEY_STORAGE = 'theo_site_pass';
    const KEY_STORAGE_LEGACY = 'theo_notes_write_key';

    function getPass(){
      try {
        return localStorage.getItem(KEY_STORAGE) || localStorage.getItem(KEY_STORAGE_LEGACY) || '';
      } catch { return ''; }
    }
    function setPass(v){
      try {
        localStorage.setItem(KEY_STORAGE, v);
        // keep legacy key in sync for older pages (safe to remove later)
        localStorage.setItem(KEY_STORAGE_LEGACY, v);
      } catch {}
    }
    function clearPass(){
      try {
        localStorage.removeItem(KEY_STORAGE);
        localStorage.removeItem(KEY_STORAGE_LEGACY);
      } catch {}
    }

    async function b64ToBytes(b64){
      const bin = atob(String(b64).replace(/\n/g,''));
      const out = new Uint8Array(bin.length);
      for (let i=0;i<bin.length;i++) out[i]=bin.charCodeAt(i);
      return out;
    }

    async function decryptToken(pass){
      const enc = await fetch('./gh-token.enc.json', { cache: 'no-store' }).then(r=>r.json());
      const salt = await b64ToBytes(enc.salt);
      const iv = await b64ToBytes(enc.iv);
      const ct = await b64ToBytes(enc.ct);
      const tag = await b64ToBytes(enc.tag);
      const data = new Uint8Array(ct.length + tag.length);
      data.set(ct, 0);
      data.set(tag, ct.length);

      const baseKey = await crypto.subtle.importKey(
        'raw',
        new TextEncoder().encode(pass),
        { name: 'PBKDF2' },
        false,
        ['deriveKey']
      );

      const aesKey = await crypto.subtle.deriveKey(
        { name: 'PBKDF2', salt, iterations: enc.iter || 150000, hash: 'SHA-256' },
        baseKey,
        { name: 'AES-GCM', length: 256 },
        false,
        ['decrypt']
      );

      const pt = await crypto.subtle.decrypt(
        { name: 'AES-GCM', iv },
        aesKey,
        data
      );

      return new TextDecoder('utf-8').decode(new Uint8Array(pt));
    }

    // gate overlay
    const gate = document.createElement('div');
    gate.style.cssText = 'position:fixed;inset:0;display:grid;place-items:center;padding:18px;background:rgba(245,249,255,0.66);backdrop-filter:blur(14px);z-index:99;';
    gate.innerHTML = `
      <div style="box-sizing:border-box;width:min(520px,calc(100% - 8px));max-width:100%;border-radius:24px;background:linear-gradient(180deg, rgba(255,255,255,0.88), rgba(255,255,255,0.72));border:1px solid rgba(31,102,227,0.14);box-shadow:0 28px 90px rgba(11,42,120,0.18);padding:18px 16px;overflow:hidden;">
        <div style="font-size:18px;font-weight:950;color:rgba(0,0,0,0.84)">Theo çš„ç¢ç¢å¿µæ”¶çº³å¤„</div>
        <div style="margin-top:8px;font-size:13px;color:rgba(0,0,0,0.55);line-height:1.65">è¯·è¾“å…¥ 4 ä½æ•°å£ä»¤ï¼Œå§å§å’Œæˆ‘ç¬¬ä¸€æ¬¡è§é¢çš„æ—¥å­ï½</div>
        <input id="keyInput" type="password" placeholder="å£ä»¤" style="box-sizing:border-box;margin-top:12px;width:100%;max-width:100%;border-radius:16px;border:1px solid rgba(31,102,227,0.16);padding:11px 12px;font-size:14px;outline:none;background:rgba(255,255,255,0.92);" />
        <div id="keyErr" style="margin-top:10px;font-size:13px;color:#b0003a;display:none">å£ä»¤ä¸å¯¹å“¦ï¼Œå†è¯•ä¸€æ¬¡ï½</div>
        <div style="margin-top:12px;display:flex;gap:10px;flex-wrap:wrap;justify-content:flex-end">
          <button id="keyOk" class="primary" style="border:0;border-radius:999px;padding:10px 14px;font-size:14px;cursor:pointer;background:linear-gradient(135deg,#0b2a78,#5aa7ff);color:#fff;font-weight:900;">è¿›å…¥</button>
        </div>
      </div>
    `;

    let GH_TOKEN = '';
    const GH_OWNER = 'xcuicui';
    const GH_REPO = 'theo-notes';

    async function ensurePassAndToken(){
      const tryPass = async (p) => {
        try {
          const tok = await decryptToken(p);
          // quick sanity check
          if (!tok || tok.length < 10) throw new Error('bad');
          GH_TOKEN = tok;
          setPass(p);
          return true;
        } catch {
          return false;
        }
      };

      const existing = getPass();
      if (existing) {
        const ok = await tryPass(existing);
        if (ok) {
          // If pass is already stored and valid, skip gate and render immediately.
          render();
          return;
        }
        clearPass();
      }

      document.body.appendChild(gate);
      const input = gate.querySelector('#keyInput');
      const err = gate.querySelector('#keyErr');
      const btn = gate.querySelector('#keyOk');

      const submit = async () => {
        err.style.display = 'none';
        const v = String(input.value || '').trim();
        if (!v) return;
        const ok = await tryPass(v);
        if (ok) {
          gate.remove();
          render();
        } else {
          err.style.display = 'block';
        }
      };

      btn.onclick = submit;
      input.addEventListener('keydown', (e) => { if (e.key === 'Enter') submit(); });
      input.focus();
    }

    // --- GitHub API helpers ---
    async function ghFetch(path, opts = {}){
      const url = `https://api.github.com${path}`;
      const res = await fetch(url, {
        ...opts,
        headers: {
          'authorization': `Bearer ${GH_TOKEN}`,
          'accept': 'application/vnd.github+json',
          'x-github-api-version': '2022-11-28',
          ...(opts.headers || {}),
        }
      });
      if (!res.ok) {
        const t = await res.text();
        throw new Error(`${res.status} ${t.slice(0, 200)}`);
      }
      return res.json();
    }

    async function ghFetchRaw(repoPath){
      const enc = repoPath.split('/').map(encodeURIComponent).join('/');
      const url = `https://api.github.com/repos/${encodeURIComponent(GH_OWNER)}/${encodeURIComponent(GH_REPO)}/contents/${enc}?ref=main`;
      const res = await fetch(url, {
        headers: {
          'authorization': `Bearer ${GH_TOKEN}`,
          'accept': 'application/vnd.github.raw',
          'x-github-api-version': '2022-11-28',
        }
      });
      if (!res.ok) {
        const t = await res.text();
        throw new Error(`${res.status} ${t.slice(0, 200)}`);
      }
      return res.blob();
    }

    async function ghPutFile(path, contentBase64, message){
      const url = `/repos/${GH_OWNER}/${GH_REPO}/contents/${encodeURIComponent(path).replaceAll('%2F','/')}?ref=main`;
      let sha;
      try {
        const j = await ghFetch(url);
        sha = j && j.sha;
      } catch {}

      const putUrl = `/repos/${GH_OWNER}/${GH_REPO}/contents/${encodeURIComponent(path).replaceAll('%2F','/')}`;
      return ghFetch(putUrl, {
        method: 'PUT',
        headers: { 'content-type': 'application/json' },
        body: JSON.stringify({ message, content: contentBase64, branch: 'main', sha }),
      });
    }

    async function ghListDir(repoPath){
      const enc = repoPath.split('/').map(encodeURIComponent).join('/');
      return ghFetch(`/repos/${GH_OWNER}/${GH_REPO}/contents/${enc}?ref=main`);
    }

    async function loadLegacyMdDay(dayStr){
      // Legacy fallback: notes/YYYY-MM-DD/*.md (+ images referenced as images/..)
      const dayDir = `notes/${dayStr}`;
      let dayList;
      try {
        dayList = await ghListDir(dayDir);
      } catch {
        return { day: dayStr, items: [] };
      }

      const mdFiles = (Array.isArray(dayList) ? dayList : [])
        .filter(x => x && x.type === 'file' && typeof x.name === 'string' && x.name.endsWith('.md'))
        .map(x => x.name)
        .sort((a,b) => b.localeCompare(a));

      const items = [];
      for (const name of mdFiles.slice(0, 60)) {
        try {
          const file = await ghGetFile(`${dayDir}/${name}`);
          const md = file.encoding === 'base64' ? b64ToUtf8(file.content) : '';

          // text: strip first heading line
          const body = md.replace(/^#.*\n+/, '').trim();

          // images: legacy relative images/... inside the same dayDir
          const rels = Array.from(md.matchAll(/!\[]\((images\/[^)]+)\)/g)).map(m => m[1]);
          const images = rels.map(r => `${dayDir}/${r}`);

          // ts: try parse from heading
          let ts = Date.now();
          const m = md.match(/^#\s*(\d{4}-\d{2}-\d{2})\s+(\d{2}):(\d{2}):(\d{2})/m);
          if (m) {
            const dt = new Date(`${m[1]}T${m[2]}:${m[3]}:${m[4]}+08:00`);
            if (!Number.isNaN(dt.getTime())) ts = dt.getTime();
          }
          items.push({ ts, text: body, images });
        } catch {}
      }

      items.sort((a,b) => (b.ts||0) - (a.ts||0));
      return { day: dayStr, items };
    }

    async function ghGetFile(repoPath){
      const enc = repoPath.split('/').map(encodeURIComponent).join('/');
      const j = await ghFetch(`/repos/${GH_OWNER}/${GH_REPO}/contents/${enc}?ref=main`);
      if (!j || j.type !== 'file') throw new Error('not_file');

      // GitHub Contents API may omit `content` for large binaries.
      // It usually provides download_url which we can fetch as raw bytes.
      const download_url = j.download_url || '';

      if (j.content) {
        return { content: j.content, encoding: j.encoding, path: j.path, name: j.name, download_url, sha: j.sha };
      }

      // Fallback 1: blobs API (may truncate for large blobs)
      if (j.sha) {
        const b = await ghFetch(`/repos/${GH_OWNER}/${GH_REPO}/git/blobs/${j.sha}`);
        return {
          content: b.content,
          encoding: b.encoding,
          path: j.path,
          name: j.name,
          download_url,
          sha: j.sha,
          truncated: !!b.truncated,
        };
      }

      return { content: '', encoding: 'base64', path: j.path, name: j.name, download_url, sha: j.sha };
    }

    function mimeFromPath(p){
      const s = String(p || '').toLowerCase();
      if (s.endsWith('.jpg') || s.endsWith('.jpeg')) return 'image/jpeg';
      if (s.endsWith('.png')) return 'image/png';
      if (s.endsWith('.gif')) return 'image/gif';
      if (s.endsWith('.webp')) return 'image/webp';
      if (s.endsWith('.heic')) return 'image/heic';
      return 'application/octet-stream';
    }

    function b64ToUtf8(b64){
      const bin = atob(String(b64).replace(/\n/g,''));
      const bytes = Uint8Array.from(bin, c => c.charCodeAt(0));
      return new TextDecoder('utf-8').decode(bytes);
    }

    async function ghTryGetJson(path){
      try {
        const f = await ghGetFile(path);
        const txt = f.encoding === 'base64' ? b64ToUtf8(f.content) : '';
        return JSON.parse(txt);
      } catch {
        return null;
      }
    }

    async function ghTryGetJsonWithSha(path){
      try {
        const f = await ghGetFile(path);
        const txt = f.encoding === 'base64' ? b64ToUtf8(f.content) : '';
        return { json: JSON.parse(txt), sha: f.sha || '' };
      } catch {
        return null;
      }
    }

    let notesIndex = { items: [] };
    const dayCache = new Map(); // day -> daily json

    // reactions cache (day -> reactions json)
    const reactCache = new Map();
    // pending operations (day -> entryId -> key -> {desired,user})
    const reactOps = new Map();
    // debounce timers per day
    const reactTimers = new Map();
    const REACT_DEBOUNCE_MS = 1200;

    // comments cache (day -> comments json)
    const commentCache = new Map();

    const REACTIONS = [
      { key: 'flutter', label: 'å¿ƒåŠ¨', icon: 'ğŸ’“' },
      { key: 'hug', label: 'æ‹¥æŠ±', icon: 'ğŸ«‚' },
      { key: 'coffee', label: 'é€’å’–å•¡', icon: 'â˜•ï¸' },
      { key: 'cake', label: 'å°è›‹ç³•', icon: 'ğŸ°' },
      { key: 'bliss', label: 'å¹¸ç¦', icon: 'ğŸ¥°' },
    ];

    let selectedDay = '';
    let viewY = 0;
    let viewM = 0;

    // index cache (speed up calendar load)
    const INDEX_CACHE_KEY = 'theo_notes_index_cache_v1';
    const INDEX_CACHE_TTL_MS = 60 * 60 * 1000; // 1 hour

    function loadIndexCache(){
      try {
        const raw = localStorage.getItem(INDEX_CACHE_KEY);
        if (!raw) return null;
        const j = JSON.parse(raw);
        if (!j || typeof j !== 'object') return null;
        if (!j.ts || !j.data) return null;
        if ((Date.now() - j.ts) > INDEX_CACHE_TTL_MS) return null;
        return j.data;
      } catch {
        return null;
      }
    }
    function saveIndexCache(data){
      try {
        localStorage.setItem(INDEX_CACHE_KEY, JSON.stringify({ ts: Date.now(), data }));
      } catch {}
    }

    function ymKey(y,m){ return `${y}-${String(m).padStart(2,'0')}`; }
    function renderWeek(){
      const w = $('calWeek');
      if (!w) return;
      w.innerHTML = '';
      for (const n of ['ä¸€','äºŒ','ä¸‰','å››','äº”','å…­','æ—¥']){
        const d = document.createElement('div');
        d.textContent = n;
        w.appendChild(d);
      }
    }

    function renderCalendar(year, month){
      const calTitle = $('calTitle');
      const grid = $('calGrid');
      if (!calTitle || !grid) return;

      calTitle.textContent = `${year} / ${String(month).padStart(2,'0')}`;
      grid.innerHTML = '';

      const first = new Date(year, month-1, 1);
      const startDow = (first.getDay() + 6) % 7; // Monday=0
      const daysInMonth = new Date(year, month, 0).getDate();

      // days set with entries
      const hasDays = new Set();
      for (const it of (notesIndex.items || [])) {
        if (!it.day) continue;
        if (String(it.day).startsWith(ymKey(year,month))) hasDays.add(it.day);
      }

      const today = new Date();
      const todayStr = `${today.getFullYear()}-${String(today.getMonth()+1).padStart(2,'0')}-${String(today.getDate()).padStart(2,'0')}`;

      // leading blanks
      for (let i=0;i<startDow;i++) {
        const d = document.createElement('div');
        d.className = 'calCell dim';
        grid.appendChild(d);
      }

      for (let day=1; day<=daysInMonth; day++) {
        const dayStr = `${year}-${String(month).padStart(2,'0')}-${String(day).padStart(2,'0')}`;
        const cell = document.createElement('div');
        cell.className = 'calCell' + (hasDays.has(dayStr) ? ' has' : '');
        if (dayStr === todayStr) cell.className += ' today';
        if (dayStr === selectedDay) cell.className += ' sel';
        cell.dataset.day = dayStr;
        cell.innerHTML = `<div class="calNum">${day}</div>` + (hasDays.has(dayStr) ? `<div class="calDot"></div>` : '');
        cell.onclick = () => loadDay(dayStr);
        grid.appendChild(cell);
      }
    }

    function markSelected(dayStr){
      const grid = $('calGrid');
      if (!grid) return;
      grid.querySelectorAll('.calCell.sel').forEach(el => el.classList.remove('sel'));
      const hit = grid.querySelector(`.calCell[data-day="${dayStr}"]`);
      if (hit) hit.classList.add('sel');
    }

    async function renderDay(dayStr){
      const list = $('list');
      const title = $('dayTitle');
      if (title) title.textContent = `${dayStr} çš„ç¢ç¢å¿µ`;
      if (!list) return;

      const daily = dayCache.get(dayStr) || { items: [] };
      const items = Array.isArray(daily.items) ? daily.items : [];

      list.innerHTML = '';
      if (!items.length) {
        list.innerHTML = '<div class="meta">è¿™ä¸€å¤©è¿˜æ²¡æœ‰è®°å½•ï½</div>';
        return;
      }

      for (const it of items) {
        const div = document.createElement('div');
        div.className = 'item';

        const meta = document.createElement('div');
        meta.className = 'meta';
        const who = it.author ? `${it.author} Â· ` : '';
        meta.textContent = who + new Date(it.ts || Date.now()).toLocaleString('zh-CN');

        const text = document.createElement('div');
        text.className = 'text';
        text.textContent = it.text || '';

        div.appendChild(meta);
        if (text.textContent) div.appendChild(text);

        const imgsArr = Array.isArray(it.images) ? it.images : [];
        if (imgsArr.length) {
          const btn = document.createElement('button');
          btn.textContent = `æŸ¥çœ‹ç…§ç‰‡ï¼ˆ${imgsArr.length}ï¼‰`;
          btn.style.marginTop = '10px';

          const imgs = document.createElement('div');
          imgs.className = 'imgs';
          imgs.style.display = 'none';

          btn.onclick = async () => {
            if (imgs.style.display === 'none') {
              imgs.style.display = 'flex';
              btn.textContent = 'æ”¶èµ·ç…§ç‰‡';

              if (imgs.childElementCount === 0) {
                // show loading hint
                const hint = document.createElement('div');
                hint.className = 'meta';
                hint.textContent = 'ç…§ç‰‡åŠ è½½ä¸­â€¦';
                imgs.appendChild(hint);

                let okCount = 0;
                let failCount = 0;

                for (const p of imgsArr.slice(0, 12)) {
                  try {
                    // Strategy (similar to original repo, but safer):
                    // 1) Try fetch raw via GitHub API (best for large private binaries)
                    // 2) Fallback to base64 content from Contents API (small files)
                    let blob;
                    try {
                      blob = await ghFetchRaw(p);
                    } catch (e1) {
                      const imgFile = await ghGetFile(p);
                      const b64 = String(imgFile.content || '').replace(/\n/g,'');
                      if (!b64) throw e1;
                      const bin = atob(b64);
                      const bytes = Uint8Array.from(bin, c => c.charCodeAt(0));
                      blob = new Blob([bytes], { type: mimeFromPath(p) });
                    }

                    const url = URL.createObjectURL(blob);
                    const img = document.createElement('img');
                    img.alt = 'photo';
                    img.loading = 'lazy';
                    img.src = url;
                    img.onclick = () => openImg(url);
                    imgs.appendChild(img);
                    okCount += 1;
                  } catch (e) {
                    failCount += 1;
                    console.warn('image load failed', p, e);
                  }
                }

                hint.remove();

                if (okCount === 0) {
                  const err = document.createElement('div');
                  err.className = 'meta';
                  err.textContent = 'ç…§ç‰‡åŠ è½½å¤±è´¥ï¼ˆå¯èƒ½æ˜¯æµè§ˆå™¨é™åˆ¶æˆ–æƒé™é—®é¢˜ï¼‰ã€‚ä½ å¯ä»¥å°è¯•ï¼šå¤åˆ¶é“¾æ¥åˆ° Safari/Chrome æ‰“å¼€ï¼Œå†è¯•ä¸€æ¬¡ã€‚';
                  imgs.appendChild(err);
                } else if (failCount > 0) {
                  const warn = document.createElement('div');
                  warn.className = 'meta';
                  warn.textContent = `æœ‰ ${failCount} å¼ ç…§ç‰‡æ²¡åŠ è½½å‡ºæ¥ï¼ˆå¯èƒ½æ ¼å¼ä¸å…¼å®¹ï¼Œä¾‹å¦‚ HEICï¼‰ã€‚`;
                  imgs.appendChild(warn);
                }
              }
            } else {
              imgs.style.display = 'none';
              btn.textContent = `æŸ¥çœ‹ç…§ç‰‡ï¼ˆ${imgsArr.length}ï¼‰`;
            }
          };

          div.appendChild(btn);
          div.appendChild(imgs);
        }

        // reply button + panel (reactions + comments)
        const user = currentUser();
        const eid = entryId(dayStr, it.ts);
        const rs = getReactState(dayStr, eid).reactions;

        const replyRow = document.createElement('div');
        replyRow.className = 'replyRow';

        const replyBtn = document.createElement('button');
        replyBtn.type = 'button';
        replyBtn.className = 'replyBtn';
        replyBtn.textContent = 'å›å¤';

        const summary = document.createElement('div');
        summary.className = 'replySummary';

        const panel = document.createElement('div');
        panel.className = 'replyPanel';

        const bar = document.createElement('div');
        bar.className = 'reactions';

        const { doc: cdoc0, arr: carr0 } = getComments(dayStr, eid);

        const renderSummary = () => {
          // reactions summary
          let reactParts = [];
          for (const def of REACTIONS) {
            const arr = Array.isArray(rs[def.key]) ? rs[def.key] : [];
            const names = whoText(arr);
            if (names) reactParts.push(`${def.icon}${names}`);
          }
          const reactTxt = reactParts.length ? reactParts.join(' ') : '';

          // comments summary
          const { arr } = getComments(dayStr, eid);
          const n = arr.length;
          const last = n ? arr[n-1] : null;
          const lastTxt = last && last.text ? String(last.text).slice(0, 40) : '';
          const cmTxt = n ? `å›å¤ ${n} æ¡ï¼š${lastTxt}` : '';

          const parts = [];
          if (reactTxt) parts.push(reactTxt);
          if (cmTxt) parts.push(cmTxt);
          summary.textContent = parts.join(' Â· ');
          summary.style.display = parts.length ? 'block' : 'none';
        };

        const renderPanelComments = () => {
          const { arr } = getComments(dayStr, eid);
          listEl.innerHTML = '';
          if (!arr.length) {
            const empty = document.createElement('div');
            empty.className = 'meta';
            empty.textContent = 'è¿˜æ²¡æœ‰æ–‡å­—å›å¤ï½';
            listEl.appendChild(empty);
            return;
          }
          for (const c of arr.slice(-20)) {
            const ci = document.createElement('div');
            ci.className = 'commentItem';
            const m = document.createElement('div');
            m.className = 'commentMeta';
            const who = c.author ? `${c.author} Â· ` : '';
            m.textContent = who + new Date(c.ts || Date.now()).toLocaleString('zh-CN');
            const t = document.createElement('div');
            t.className = 'commentText';
            t.textContent = c.text || '';
            ci.appendChild(m);
            ci.appendChild(t);
            listEl.appendChild(ci);
          }
        };

        // comments UI (one-line) + reactions below input
        const commentBox = document.createElement('div');
        commentBox.className = 'commentBox';

        const input = document.createElement('input');
        input.className = 'commentInput';
        input.type = 'text';
        input.placeholder = 'æƒ³å¯¹ ta è¯´ç‚¹ä»€ä¹ˆâ€¦ï¼ˆæœ€å¤š 200 å­—ï¼‰';

        const draftPill = document.createElement('div');
        draftPill.className = 'draftReacts';

        const sendBtn = document.createElement('button');
        sendBtn.type = 'button';
        sendBtn.className = 'replyBtn';
        sendBtn.textContent = 'å‘é€';

        // draft reaction toggle states (key -> desiredBool)
        const draft = {};

        function renderDraftPill(){
          const parts = [];
          for (const def of REACTIONS) {
            const arr0 = Array.isArray(rs[def.key]) ? rs[def.key] : [];
            const has = user && arr0.includes(user);
            const desired = (def.key in draft) ? !!draft[def.key] : has;
            if (desired !== has) {
              parts.push(def.icon);
            }
          }
          draftPill.textContent = parts.length ? ('å·²é€‰å¿ƒæƒ…ï¼š' + parts.join(' ')) : '';
          draftPill.style.display = parts.length ? 'block' : 'none';
        }

        // build reactions buttons (below input)
        for (const def of REACTIONS) {
          const wrap = document.createElement('div');
          wrap.className = 'reactWrap';

          const btn = document.createElement('button');
          btn.type = 'button';
          btn.className = 'reactBtn';
          btn.title = def.label;

          const icon = document.createElement('span');
          icon.className = 'reactIcon';
          icon.textContent = def.icon;

          const cnt = document.createElement('span');
          cnt.className = 'reactCount';

          const who = document.createElement('div');
          who.className = 'reactWho';

          const renderOne = () => {
            const arr = Array.isArray(rs[def.key]) ? rs[def.key] : [];
            const has = user && arr.includes(user);
            const desired = (def.key in draft) ? !!draft[def.key] : has;
            btn.classList.toggle('on', !!desired);
            const names = whoText(arr);
            cnt.textContent = names;
            cnt.style.display = names ? 'inline' : 'none';
            who.textContent = '';
            who.style.display = 'none';
            renderDraftPill();
          };

          btn.onclick = () => {
            if (!user) { toast('æœªç™»å½•ï¼Œæ— æ³•äº’åŠ¨ï½'); return; }
            const arr0 = Array.isArray(rs[def.key]) ? rs[def.key].map(String) : [];
            const has = arr0.includes(user);
            const curDesired = (def.key in draft) ? !!draft[def.key] : has;
            const desired = !curDesired;
            draft[def.key] = desired;
            renderOne();
          };

          btn.appendChild(icon);
          btn.appendChild(cnt);
          wrap.appendChild(btn);
          wrap.appendChild(who);
          bar.appendChild(wrap);
          renderOne();
        }

        const listEl = document.createElement('div');
        listEl.className = 'commentList';

        sendBtn.onclick = async () => {
          const v = String(input.value || '').trim();
          const hasDraft = Object.keys(draft).length > 0;
          if (!v && !hasDraft) return;

          // commit draft reactions (toggle) only when sending
          if (hasDraft) {
            for (const [k, desired] of Object.entries(draft)) {
              setOp(dayStr, eid, k, !!desired);
              // also update local view for summary/render
              const arr0 = Array.isArray(rs[k]) ? rs[k].map(String) : [];
              const has = user && arr0.includes(user);
              if (!!desired && !has && user) rs[k] = Array.from(new Set(arr0.concat([user])));
              if (!desired && has && user) {
                const next = arr0.filter(x => x !== user);
                if (next.length) rs[k] = next; else delete rs[k];
              }
            }
            await flushReactions(dayStr);
            for (const kk of Object.keys(draft)) delete draft[kk];
            renderDraftPill();
          }

          if (v) {
            await saveComment(dayStr, eid, v);
          }

          input.value = '';
          renderPanelComments();
          renderSummary();
        };

        input.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') {
            e.preventDefault();
            sendBtn.click();
          }
        });

        commentBox.appendChild(input);
        commentBox.appendChild(sendBtn);
        commentBox.appendChild(draftPill);

        panel.appendChild(commentBox);
        panel.appendChild(bar);
        panel.appendChild(listEl);

        replyBtn.onclick = () => {
          const open = panel.style.display !== 'none';
          panel.style.display = open ? 'none' : 'block';
          if (!open) {
            renderPanelComments();
          }
        };

        replyRow.appendChild(replyBtn);
        replyRow.appendChild(summary);

        div.appendChild(replyRow);
        div.appendChild(panel);

        renderSummary();
        list.appendChild(div);
      }
    }

    function currentUser(){
      try {
        return (window.__AUTH__ && window.__AUTH__.user) ? String(window.__AUTH__.user) : '';
      } catch { return ''; }
    }

    function entryId(day, ts){
      return `${day}:${String(ts||'')}`;
    }

    function normalizeReactionsJson(dayStr, j){
      if (!j || typeof j !== 'object') return { day: dayStr, items: {} };
      if (!j.items || typeof j.items !== 'object') j.items = {};
      j.day = j.day || dayStr;
      return j;
    }

    async function ensureReactionsLoaded(dayStr){
      if (reactCache.has(dayStr)) return;
      const path = `notes/${dayStr}/reactions.json`;
      const r = await ghTryGetJson(path);
      reactCache.set(dayStr, normalizeReactionsJson(dayStr, r));
    }

    function normalizeCommentsJson(dayStr, j){
      if (!j || typeof j !== 'object') return { day: dayStr, items: {} };
      if (!j.items || typeof j.items !== 'object') j.items = {};
      j.day = j.day || dayStr;
      return j;
    }

    async function ensureCommentsLoaded(dayStr){
      if (commentCache.has(dayStr)) return;
      const path = `notes/${dayStr}/comments.json`;
      const r = await ghTryGetJson(path);
      commentCache.set(dayStr, normalizeCommentsJson(dayStr, r));
    }

    function getComments(dayStr, eid){
      const d = commentCache.get(dayStr) || { day: dayStr, items: {} };
      if (!d.items || typeof d.items !== 'object') d.items = {};
      const arr = Array.isArray(d.items[eid]) ? d.items[eid] : [];
      return { doc: d, arr };
    }

    async function saveComment(dayStr, eid, text){
      const user = currentUser();
      if (!user) { toast('æœªç™»å½•ï¼Œæ— æ³•å›å¤ï½'); return; }
      const t = String(text||'').trim();
      if (!t) return;
      if (t.length > 200) { toast('å›å¤å¤ªé•¿å•¦ï¼ˆæœ€å¤š 200 å­—ï¼‰'); return; }

      // optimistic update
      const { doc, arr } = getComments(dayStr, eid);
      const item = { ts: Date.now(), author: user, text: t };
      const nextArr = arr.concat([item]);
      doc.items[eid] = nextArr;
      doc.updatedAt = Date.now();
      commentCache.set(dayStr, doc);

      const path = `notes/${dayStr}/comments.json`;
      for (let attempt=0; attempt<3; attempt++){
        let base = { day: dayStr, items: {} };
        try {
          const got = await ghTryGetJsonWithSha(path);
          if (got && got.json) base = normalizeCommentsJson(dayStr, got.json);
        } catch {}
        const baseArr = Array.isArray(base.items[eid]) ? base.items[eid] : [];
        base.items[eid] = baseArr.concat([item]);
        base.updatedAt = Date.now();

        try {
          await ghPutFile(path, await base64Utf8(JSON.stringify(base, null, 2)), `Add comment ${dayStr}`);
          commentCache.set(dayStr, base);
          return;
        } catch (e) {
          if (attempt === 2) {
            console.warn('save comment failed', e);
            toast('å›å¤ä¿å­˜å¤±è´¥ï¼Œç¨åå†è¯•ï½');
          }
        }
      }
    }

    function getReactState(dayStr, eid){
      const dayObj = reactCache.get(dayStr) || { day: dayStr, items: {} };
      if (!dayObj.items || typeof dayObj.items !== 'object') dayObj.items = {};
      if (!dayObj.items[eid]) dayObj.items[eid] = { updatedAt: Date.now(), reactions: {} };
      const it = dayObj.items[eid];
      it.reactions = (it.reactions && typeof it.reactions === 'object') ? it.reactions : {};
      reactCache.set(dayStr, dayObj);
      return { it, reactions: it.reactions };
    }

    function whoText(arr){
      const a = Array.isArray(arr) ? arr.filter(Boolean).map(String) : [];
      if (a.length === 0) return '';
      if (a.length === 1) return a[0];
      if (a.length === 2) return `${a[0]} Â· ${a[1]}`;
      return `${a[0]} Â· ${a[1]} +${a.length-2}`;
    }

    function scheduleFlush(dayStr){
      const old = reactTimers.get(dayStr);
      if (old) clearTimeout(old);
      reactTimers.set(dayStr, setTimeout(() => flushReactions(dayStr), REACT_DEBOUNCE_MS));
    }

    function setOp(dayStr, eid, key, desired){
      const user = currentUser();
      if (!user) return;
      if (!reactOps.has(dayStr)) reactOps.set(dayStr, {});
      const d = reactOps.get(dayStr);
      if (!d[eid]) d[eid] = {};
      d[eid][key] = { desired: !!desired, user };
    }

    function applyOpToJson(dayStr, j, eid, key, user, desired){
      j = normalizeReactionsJson(dayStr, j);
      if (!j.items[eid]) j.items[eid] = { updatedAt: Date.now(), reactions: {} };
      const node = j.items[eid];
      node.reactions = (node.reactions && typeof node.reactions === 'object') ? node.reactions : {};
      const cur = Array.isArray(node.reactions[key]) ? node.reactions[key].map(String) : [];
      const has = cur.includes(user);
      let next = cur;
      if (desired && !has) next = cur.concat([user]);
      if (!desired && has) next = cur.filter(x => x !== user);
      if (next.length) node.reactions[key] = Array.from(new Set(next));
      else delete node.reactions[key];
      node.updatedAt = Date.now();
      return j;
    }

    async function flushReactions(dayStr){
      const ops = reactOps.get(dayStr);
      if (!ops || !Object.keys(ops).length) return;

      const path = `notes/${dayStr}/reactions.json`;

      // retry on sha conflict
      for (let attempt=0; attempt<3; attempt++){
        let base = { day: dayStr, items: {} };
        try {
          const got = await ghTryGetJsonWithSha(path);
          if (got && got.json) base = normalizeReactionsJson(dayStr, got.json);
        } catch {}

        // apply ops
        for (const [eid, keys] of Object.entries(ops)){
          for (const [k, v] of Object.entries(keys||{})){
            const user = v && v.user ? String(v.user) : '';
            if (!user) continue;
            const desired = !!(v && v.desired);
            base = applyOpToJson(dayStr, base, eid, k, user, desired);
          }
        }

        try {
          await ghPutFile(path, await base64Utf8(JSON.stringify(base, null, 2)), `Update reactions ${dayStr}`);
          // update cache + clear ops
          reactCache.set(dayStr, base);
          reactOps.set(dayStr, {});
          return;
        } catch (e) {
          // likely sha conflict; try again
          if (attempt === 2) {
            console.warn('flush reactions failed', e);
            toast('äº’åŠ¨ä¿å­˜å¤±è´¥ï¼Œç¨åå†è¯•ï½');
          }
        }
      }
    }

    async function loadDay(dayStr){
      selectedDay = dayStr;
      // re-highlight selection (fast DOM toggle; fallback rerender if needed)
      markSelected(dayStr);
      if (viewY && viewM) renderCalendar(viewY, viewM);
      markSelected(dayStr);

      const list = $('list');
      if (list) list.innerHTML = '<div class="meta">æ­£åœ¨åŠ è½½å½“å¤©è®°å½•â€¦</div>';

      if (!dayCache.has(dayStr)) {
        const dailyPath = `notes/${dayStr}/entries.json`;
        let daily = await ghTryGetJson(dailyPath);
        if (!daily) {
          // fallback to legacy markdown day
          daily = await loadLegacyMdDay(dayStr);
        }
        if (!daily || typeof daily !== 'object') daily = { day: dayStr, items: [] };
        dayCache.set(dayStr, daily);
      }

      await Promise.all([
        ensureReactionsLoaded(dayStr),
        ensureCommentsLoaded(dayStr),
      ]);
      await renderDay(dayStr);
    }

    async function renderFromGitHub(){
      renderWeek();

      // default month = current
      const now = new Date();
      viewY = now.getFullYear();
      viewM = now.getMonth() + 1;

      const prevM = $('prevM');
      const nextM = $('nextM');
      const todayBtn = $('todayBtn');

      const rerender = () => {
        renderCalendar(viewY, viewM);
      };

      prevM && (prevM.onclick = () => {
        viewM -= 1;
        if (viewM <= 0) { viewM = 12; viewY -= 1; }
        rerender();
        markSelected(selectedDay);
      });
      nextM && (nextM.onclick = () => {
        viewM += 1;
        if (viewM >= 13) { viewM = 1; viewY += 1; }
        rerender();
        markSelected(selectedDay);
      });
      todayBtn && (todayBtn.onclick = async () => {
        viewY = now.getFullYear();
        viewM = now.getMonth() + 1;
        selectedDay = `${now.getFullYear()}-${String(now.getMonth()+1).padStart(2,'0')}-${String(now.getDate()).padStart(2,'0')}`;
        rerender();
        markSelected(selectedDay);
        await loadDay(selectedDay);
      });

      // default open today
      selectedDay = `${now.getFullYear()}-${String(now.getMonth()+1).padStart(2,'0')}-${String(now.getDate()).padStart(2,'0')}`;

      // instant calendar from cache
      const cached = loadIndexCache();
      if (cached && typeof cached === 'object') {
        notesIndex = cached;
        rerender();
        markSelected(selectedDay);
      }

      // start loading day immediately
      await loadDay(selectedDay);

      // refresh index in background (update cache + rerender)
      (async () => {
        const index = await ghTryGetJson('notes/index.json');
        if (index && typeof index === 'object') {
          notesIndex = index;
          saveIndexCache(index);
          rerender();
          markSelected(selectedDay);
        }
      })();
    }

    async function render(){
      try { await renderFromGitHub(); }
      catch (e) {
        console.warn(e);
        $('list').innerHTML = '<div class="meta">è¯»å–å¤±è´¥ï¼ˆè¯·ç¡®è®¤å£ä»¤æ­£ç¡®ï¼‰</div>';
      }
    }

    async function readFileAsBase64(file){
      return new Promise((resolve, reject) => {
        const r = new FileReader();
        r.onload = () => {
          const dataUrl = String(r.result || '');
          const b64 = dataUrl.split(',')[1] || '';
          resolve(b64);
        };
        r.onerror = () => reject(r.error);
        r.readAsDataURL(file);
      });
    }

    async function blobToBase64(blob){
      return new Promise((resolve, reject) => {
        const r = new FileReader();
        r.onload = () => {
          const dataUrl = String(r.result || '');
          const b64 = dataUrl.split(',')[1] || '';
          resolve(b64);
        };
        r.onerror = () => reject(r.error);
        r.readAsDataURL(blob);
      });
    }

    async function compressToJpegBase64(file, opts = {}){
      const { maxSide = 1600, quality = 0.82 } = opts;
      // Use <img> + canvas; Safari can usually decode HEIC for display, and canvas can re-encode to JPEG.
      const url = URL.createObjectURL(file);
      try {
        const img = await new Promise((resolve, reject) => {
          const im = new Image();
          im.onload = () => resolve(im);
          im.onerror = reject;
          im.src = url;
        });

        const w0 = img.naturalWidth || img.width;
        const h0 = img.naturalHeight || img.height;
        if (!w0 || !h0) throw new Error('bad_image');

        const scale = Math.min(1, maxSide / Math.max(w0, h0));
        const w = Math.max(1, Math.round(w0 * scale));
        const h = Math.max(1, Math.round(h0 * scale));

        const canvas = document.createElement('canvas');
        canvas.width = w;
        canvas.height = h;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(img, 0, 0, w, h);

        const blob = await new Promise((resolve) => canvas.toBlob(resolve, 'image/jpeg', quality));
        if (!blob) throw new Error('toBlob_failed');
        const b64 = await blobToBase64(blob);
        return { b64, ext: 'jpg', mime: 'image/jpeg' };
      } finally {
        URL.revokeObjectURL(url);
      }
    }

    async function imageToUploadPayload(file){
      // If it's HEIC/HEIF or very large, compress to JPEG for better compatibility.
      const name = String(file.name || '');
      const ext0 = (name.split('.').pop() || '').toLowerCase();
      const isHeic = (file.type && /heic|heif/i.test(file.type)) || ext0 === 'heic' || ext0 === 'heif';
      const isBig = (file.size || 0) > 2.5 * 1024 * 1024;

      if (isHeic || isBig) {
        try {
          return await compressToJpegBase64(file, { maxSide: 1600, quality: 0.82 });
        } catch (e) {
          console.warn('compress fail, fallback original', e);
        }
      }

      const b64 = await readFileAsBase64(file);
      const ext = ext0 || (file.type==='image/jpeg'?'jpg':file.type==='image/png'?'png':'bin');
      return { b64, ext, mime: file.type || mimeFromPath(ext) };
    }

    async function base64Utf8(str){
      const bytes = new TextEncoder().encode(str);
      let bin = '';
      bytes.forEach(b => bin += String.fromCharCode(b));
      return btoa(bin);
    }

    $('saveGitHub').onclick = async () => {
      const btn = $('saveGitHub');
      const text = $('text').value.trim();
      const files = selectedFiles.length ? selectedFiles : Array.from($('photos').files || []);
      if (!text && files.length === 0) {
        toast('å†™ç‚¹ä»€ä¹ˆæˆ–ä¼ å¼ ç…§ç‰‡å†ä¿å­˜å“¦ï½');
        return;
      }

      const oldLabel = btn ? btn.textContent : '';
      btn && (btn.disabled = true);
      btn && (btn.textContent = 'ä¿å­˜ä¸­â€¦');

      try {
        const ts = Date.now();
        const d = new Date(ts);
        const yyyy = d.getFullYear();
        const mm = String(d.getMonth()+1).padStart(2,'0');
        const dd = String(d.getDate()).padStart(2,'0');
        const HH = String(d.getHours()).padStart(2,'0');
        const MM = String(d.getMinutes()).padStart(2,'0');
        const SS = String(d.getSeconds()).padStart(2,'0');
        const day = `${yyyy}-${mm}-${dd}`;
        const dayDir = `notes/${day}`;
        const stamp = `${HH}${MM}${SS}`;

        // optimistic: update UI immediately (text + placeholders)
        const author = (window.__AUTH__ && window.__AUTH__.user) ? String(window.__AUTH__.user) : '';
        const optimisticEntry = { ts, text, images: [], author };
        if (!dayCache.has(day)) dayCache.set(day, { day, items: [] });
        const daily0 = dayCache.get(day);
        daily0.items = Array.isArray(daily0.items) ? daily0.items : [];
        daily0.items.unshift(optimisticEntry);

        notesIndex.items = Array.isArray(notesIndex.items) ? notesIndex.items : [];
        notesIndex.items.unshift({ ts, day, text, images: [] });
        notesIndex.items = notesIndex.items.slice(0, 200);

        selectedDay = day;
        // jump calendar view to current month
        const now = new Date();
        const viewY = now.getFullYear();
        const viewM = now.getMonth() + 1;
        renderCalendar(viewY, viewM);
        await renderDay(day);

        // upload images
        const imgPaths = [];
        for (let i=0;i<files.length;i++) {
          const f = files[i];
          const payload = await imageToUploadPayload(f);
          const ext = payload.ext;
          const path = `${dayDir}/images/${stamp}-${i+1}.${ext}`;
          imgPaths.push(path);
          btn && (btn.textContent = `ä¸Šä¼ ç…§ç‰‡ ${i+1}/${files.length}â€¦`);
          await ghPutFile(path, payload.b64, `Add photo ${day} ${stamp} #${i+1}`);
        }

        // Append to daily JSON
        const dailyPath = `${dayDir}/entries.json`;
        const daily = (await ghTryGetJson(dailyPath)) || { day, items: [] };
        daily.items = Array.isArray(daily.items) ? daily.items : [];
        daily.items.unshift({ ts, text, images: imgPaths, author });
        await ghPutFile(dailyPath, await base64Utf8(JSON.stringify(daily, null, 2)), `Update daily entries ${day}`);

        // Update index.json (fast list)
        const idxPath = 'notes/index.json';
        const idx = (await ghTryGetJson(idxPath)) || { items: [] };
        idx.items = Array.isArray(idx.items) ? idx.items : [];
        idx.items.unshift({ ts, day, text, images: imgPaths, author });
        idx.items = idx.items.slice(0, 200);
        await ghPutFile(idxPath, await base64Utf8(JSON.stringify(idx, null, 2)), `Update notes index ${day}`);
        saveIndexCache(idx);

        // update optimistic entry to real image paths
        optimisticEntry.images = imgPaths;

        $('text').value = '';
        $('photos').value = '';
        selectedFiles = [];
        renderThumbs();

        toast('å·²ä¿å­˜ï½');
        await loadDay(day);
      } catch (e) {
        toast('ä¿å­˜å¤±è´¥ï¼š' + String(e).slice(0, 120));
      } finally {
        btn && (btn.disabled = false);
        btn && (btn.textContent = oldLabel || 'è®°å½•');
      }
    };

    ensurePassAndToken();
  </script>
</body>
</html>
